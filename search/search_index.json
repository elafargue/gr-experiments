{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Experiments in software radio Preamble THESE ARE MY OWN NOTES AFTER WORKING WITH GNURADIO FOR A WHILE, NO PROMISE OF ANY FITNESS FOR ANY PARTICULAR PURPOSE. A lot of those flowgraphs are my own, some are adapted/copied from various sources online. If you recognize your work and think it is missing attribution, please reach out and I will add proper credit where it's due. I simply haven't tracked down all my sources as I went along... Introduction GNURadio is an amazing framework for all things related radio digital signal processing, and it is as powerful as it is daunting: it is a fairly venerable project started in 2001, and has always been a real adventure to install on any computer. The main gnuradio documentation, maintained on wiki.gnuradio.org, will usually help, but it is all in all fairly sparse and often quite arcane. There is a lot of material out there about GNURadio, with varying degrees of relevance, accuracy, compatibility with the current versions of GNURadio. This guide is an attempt at covering most of the basics of building GNURadio flowgraphs to process most common radio modulations, along with examples of more advanced software, often based on GNURadio, designed to fully demodulate various categories of radio signals. A common challenge for many newcomers is that GNURadio is before anything else a digital signal processing framework: despite the 'Lego'-like approach of building flowgraphs on GNURadio Companion, you will always be very limited in what you can achieve without proper understanding of the fundamentals of digital signal processing. There are a lot of excellent resources on the web for learning this (see the links section below), as well as many university courses, and if you are seriously planning to use GNURadio for real projects, learning - or taking a refresher on - digital signal processing is really a must. This guide is an attempt at getting you up and running on GNURadio as of early 2019, and introduce you to the basic building blocks of the framework, so that you can in turn use GNURadio for your own projects. Last, this guide is heavily biased towards MacOS, and everything in here is working with GNURadio version 3.7.14. YMMV. Links A lot of the material in the following links is useful for learning not only about GNURadio, but also about digital signal processing. Introduction to quadrature signals by dspguru . An excellent and approachable paper. balint256 YouTube channel . The GNURadio video tutorial there is outdated, but contains a lot of great fundamentals, definitely worth a watch. http://complextoreal.com/tutorials/ Variants of GNURadio - main/next/etc GNURadio uses a concept of \"gnuradio\" and \"gnuradio-next\" for its stable and development branches. The stable branch is usually the way to go. Installing GNURadio https://wiki.gnuradio.org/index.php/InstallingGR is the official documentation. Below are my own notes on how to actually get it to work As of early 2020, the only version of GNURadio that is \"easy\" to install and compatible with most 3rd party modules is 3.7, despite the fact that 3.8 was released mid-2019. This is changing relatively rapidly though, so double-check. Linux Most distributions do have a gnuradio package. Be careful though, those versions are often out of date, especially the 'stable' versions. My advice is to first check out the version of GNURadio that is available on your package manager, then decide whether you want to go to the trouble of going a source code install, which is not a super trivial task. That said, GNURadio has improved that respect a lot over the years by using their own Python system they call \"PyBOMBS\". If you want to attempt a source install, follow the guide at: https://wiki.gnuradio.org/index.php/InstallingGRFromSource Running in a Linux VM While running GNURadio inside a Linux VM works fine, you will probably encounter performance issues when using it with physical SDR radios over USB, so a native version is usually preferable. MacOS MacOS does run GNURadio quite well, and has its own install page on the GNURadio wiki: https://wiki.gnuradio.org/index.php/MacInstall As with Linux, using a package manager is a good idea if the package is not too outdated. Macports is usually considered as the most stable and maintained port for GNURadio, but Homebrew has been making great progress lately, and will get you up and running quite well. As of 2019.04, my advice is to go the Macports way to install the stable version of GNURadio, it does work well and closely follows the GNURadio project releases. MacOS quirks As usual with Open Source projects, there are a bunch of weird quirks for running various parts of GNURadio, in particular when using Gnuradio Companion with Qt blocks: the symptom is the UI flickering very fast. This can be easily solved though, by configuring the global settings at ~/.gnuradio/config.conf with: [qtgui] style = native If you installed GNURadio through MacPorts, you might have to explicitly tell cmake to point to /opt/local when compiling OOT (\"Out of tree\") modules: cmake -DCMAKE_INSTALL_PREFIX=/opt/local .. Using PyBOMBS Apparently, some say this is possible on MacOS X... I have not attempted this. Optimization tricks ToDo: speak about hardware acceleration, expectations of performance, etc. GNURadio companion GNURadio companion is the graphical flow graph editor of GNURadio, and a great way to do rapid prototyping on this framework. While you will probably want to work in either C++ or Python for production usage if you intend to use the GNURadio framework for your own applications, GNURadio companion is a perfect tool for doing lab work and general signal hacking. GNURadio companion uses a graphical editor to layout GNURadio blocks and connect them together. GNURadio blocks GNURadio uses a concept of signal processing blocks. Those blocks can be written in a variety of languages, from Python to C++, with C++ implementations being usually faster than Python. There is documentation on the GNURadio wiki about writing modules, that might or might not be matching the current version of GNURadio, but will in any case provide a bit of help. ToDo: describe the blocks, what they do, etc. Other useful utilities Those are utilities I have found really useful in working with new signals: gqrx gqrx is an easy(ish) to use software defined radio receiver, that is a great tool for quickly visualizing a signal. ToDo: examples of signals and how to recognize them URH Universal Radio Hacker is a lower level tool that can be very powerful to understand digital modulations and quickly do demodulation work. It comes with excellent documentation for an Open Source project, which is a really refreshing change. ToDo: examples of demodulating a signal with URH MacOS notes Macports does not have a URH port, but you can install all of its dependencies from macports. Then you can run it, but be sure to export CFLAGS=\"-I /opt/local/include before either doing a pip install or running from the source tree. In order to compile SDR extensions on MacOS with Macports, use the fork at https://github.com/elafargue/urh which supports that distribution. ToDo: URH tutorial Inspectrum Inspectrum is similar to URH but written in C++. It is fairly simple to build and is a good addition to any signal processing toolbox. SDR setups rtl-sdr Support for the RTL-SDR family on GNURadio is done through the gr-osmosdr module. USRP USRP is extremely well supported by GNURadio, of course. the uhd Macports module implements this. osmocom / BladeRF Simple analog operations FM Demodulation FM demodulation is fairly simple: a FM-modulated signal is a carrier whose frequency varies proportionnal to the signal that we want to transmit. See wikipedia for the basics. From a Gnuradio companion perspective, it is very simple to represent in a flowgraph: Flowgraph file is here . This is a good first example, because it covers the very basics of what digital signal processing of radio signals is about. A great introduction to this, in case you do not yet understand the principle of working with in-phase and quadrature (aka IQ) signal components, is the introduction by dspguru . AM Demodulation AM demodulation is similar: an AM-modulated signal is also a carrier, but this time the amplitude of this carrier varies along with the signal we want to transmit. We can simply demodulate this signal by detecting the envelope of the received signal: The most basic GNURadio flowgraph for this would be as follows: Flowgraph file is here . note: this refers to the example data file available at the excellent course at: http://www.csun.edu/~skatz/katzpage/sdr_project/ . You should look up this site to learn more able AM and SSB in relation to digital radio. SSB Demodulation Single side band is an energy-efficient variant of amplitude modulation. Essentially, it is AM modulation with the carrier suppressed, and only one of the sidebands transmitted. It is not difficult to modulate, but demodulating it is slightly more complex. There are a couple of DSP algorithms out there for doing this, but Weaver is by far the most popular because it is very well suited to software defined radio. Reference links: Very good overview of SSB demodulation techniques Course on Weaver demodulation with clear explanation of the technique (todo: insert flowgraph of my own SSB receiver) Flowgraph file is here Analog and digital video Quick side note on video: there is a great utility that works with \"Tempest\" radiated transmission on video signals (TODO: more background on Tempest): TempestSDR, which works great with the USRP. TempestSDR . Works great on the Mac. You will need to patch a couple of things to make it run, but nothing bad: --- a/TSDRPlugin_UHD/src/TSDRPlugin_UHD.cpp +++ b/TSDRPlugin_UHD/src/TSDRPlugin_UHD.cpp @@ -14,7 +14,7 @@ #include <stdlib.h> #include <string.h> -#include <uhd/utils/thread_priority.hpp> +#include <uhd/utils/thread.hpp> #include <uhd/utils/safe_main.hpp> #include <uhd/usrp/multi_usrp.hpp> #include <uhd/transport/udp_simple.hpp> @@ -332,7 +332,7 @@ EXTERNC TSDRPLUGIN_API int __stdcall tsdrplugin_readasync(tsdrplugin_readasync_f // flush usrpbuffer while(rx_stream->recv( buff, samples_per_api_read, md, - uhd::device::RECV_MODE_ONE_PACKET + true )){ /* NOP */ }; Digital operations Nowadays, radio signals are often used to transmit bits rather than analog information. This section covers some common techniques used for doing this. Basics of digital operations Digital signals are usually modulated using a combination of the amplitude, frequency and phase of a signal. To make demodulation easier, binary data is often encapsulated into frames that usually contain: A start sequence, used by the demodulator to synchronise itself to the incoming bitstream Some sort of header that contains the expected length of the frame Error correcting codes, either throughout or at the end of the frame. Digital to analogue conversion, besides modulating a bitstream using Amplitude/Frequency/Phase or a combination of all of these, also uses a notion of \"symbols\": instead of doing a one-to-one conversion of a \"0\" or \"1\" into two discrete analogue signal states, a lot of modulation schemes take longer bit sequences, such as \"00\" \"01\" \"10\" \"11\" and turn them into multiple discrete analogue signal states. Those sequences are called \"symbols\" and allow increasing the density of information that is sent inside of each modulation state. A demodulator therefore needs to do the following on an incoming analog signal: Demodulate the raw analogue signal to turn it in to a \"clean\" analogue signal with clear discrete states Turn that demodulated analogue signal into a symbols by knowing exactly when to sample the signal state to map it to symbols. This is called \"clock recovery\" Remap the symbols to bit values Find start sequences in the bitstream to get in sync Recover packet length \"Deframe\" the packet and check its CRC GNURadio provides a lot of blocks to do almost all of these operations, but start sequence detection and deframing is usually quite specific to each modulation type, and there is only a limited number of off the shelf blocks that can be used for this. You will often need to get into python - or C - and write your own blocks for those. The next couple of sections provide more details on some of the aspects of demodulation using GNURadio. From a more tactical perspective, what you will usually find in a flowgraph is the following: Analogue signal reception from SDR Low Pass / frequency translate to center the signal around zero hertz Analogue demodulate Clock Recovery Bitstream decoding (NRZ, Manchester, inversion, etc) Bitstream deframing The analogue part was covered to some extent in some of the basic receivers above. Clock recovery Clock recovery is essentially a process that decides when the analogue signal should be sampled to determine the symbol state. When it works well, clock recovery will sample exactly once per transmitted symbol. GNURadio provides several good clock recovery blocks in the \"Synchronizers\" category. Some of the blocks that are easier to use are: Clock Recovery MM Polyphase Clock Sync With those blocks, you will need to know the symbol rate and bitrate in advance, so that they can make the right decision for sampling the symbols. The AFSK AX25 decoder flow graph below is a good example of using the Polyphase Clock Sync or the Clock Recovery MM blocks. Processing bitstreams OOK / ASK This is one of the simplest kinds of digital modulation: a carrier that is simply turned on/off to transmit information, hence the \"OOK\" (On-Off keying) or \"ASK\" (Amplitude Shift Keying) acronyms. Useful demodulators rtl_433 is a great general purpose demodulator and decoder for OOK signals, and is able to decode more than a hundred types of simple sensors, from wireless alarm sensors to a bunch of weather sensors. rtlamr An rtl-sdr receiver for Itron ERT compatible smart meters operating in the 900MHz ISM band. Frequency shift keying Frequency Shift Keying, or \"FSK\", uses discrete frequency changes of a carrier signal for modulating a bitstream. The simplest FSk uses two frequencies, one for \"0\" and one for \"1\", but it is also possible to use a larger number of discrete frequencies to encode longer symbols - for example \"00\", \"01\", \"10\" and \"11\" can be transmitted using 4-FSK, i.e. four separate frequencies. FSK is usually demodulated using quadrature demodulation. Note that a FSK-modulated signal can be transmitted as a carrier changing over N frequencies (usually within a couple of hundred hertz of each other), or through discrete frequency changes of a signal that is FM or AM modulated. In the latter case, we usually talk about \"AFSK\", or \"Audio FSK\". Other kinds of FSK exist that were designed to improve specific aspects of this sort of modulation, such as power efficiciency. The wikipedia article on FSK is a nice introduction and easy to understand. Links https://github.com/handiko/gr-APRS A great tutorial: http://aaronscher.com/GNU_Radio_Companion_Collection/Audio_Modem_loop_back_test_FSK.html Another one: https://nccgroup.github.io/RFTM/fsk_receiver.html 2-AFSK The easiest way to demodulate a FSK transmission is to use a Quadrature demodulation block: the output of quadrature demodulation varies with the phase change that occurs at frequency transition between the FSK frequencies, so this is a good way to turn the signal into symbol states. Since 2-FSK uses only 2 frequencies, there is usually a direct mapping of the frequency to either a \"0\" or \"1\" value, though you have to keep in mind that the signal is often encoded for robustness and energy efficiency using differential or Manchester encoding. The sample AX25 receiver included in this repository is a great example of 2-AFSK reception. You can use this flowgraph and adapt it to other types of modulation fairly easily: Adjust the FSK deviation of the signal Adjust the birate Adjust the bitstream decoding after the binary slicer Note: as you can see on the flowgraph below, we are doing two demodulations. You have to keep in mind that FM modulation of an analogue signal modulates the carrier signal by an amount that is proportional to the original analogue signal, but multiplied by a \"modulation index\". For this reason, it is not possible to simply convert a FM-modulated signal into a FSK bitstream, you first need to demodulate the FM signal into the deviation-correct FSK analogue modulation, then demodulate that signal into a bitstream. Another equivalent way to look at is is that AX25 is transmitted over narrow-band HAM radio, so the flowgraph first demodulates the FM signal into an audio signal, then it does the actual Audio FSK (aka AFSK) demodulation. GRC Flowgraph code 2-FSK A good example of a 2-FSK signal is the old school \"RTTY\" modulation N-FSK Links http://qradiolink.org/4fsk-viterbi-soft-symbol-decoding.html Phase shift keying OFDM Real world examples Broadcast FM Broadcast FM is kind of a \"Hello World\" of radio reception on GNURadio, the below flowgraphs are a good example of making your first steps with it. The main difference between \"Broadcast FM\" compared to just \"FM\" modulation is the following: Broadcast FM uses a standardized frequency deviation, usually with a maximum of 75kHz Pre-emphasis is applied to the signal to offset the effect of band noise Modern FM usually is broadcast in stereo (see below or Wikipedia for details) More and more, digital information is included in the broadcast (data, audio, or both) Mono A Broadcast mono FM receiver is really a standard FM receiver with standard deviation and de-emphasis applied. It is identical to the flowgraph shown above on basic FM reception: Flowgraph Stereo Stereo signals are transmitted at a set of two channels: the \"R+L\" channels at baseband audio frequency, and \"R-L\" centered on 38kHz higher. This makes them compatible with mono receivers that will just demodulate the R+L component. A 19kHz pilot tone is also added to help receivers detect the presence of a stereo signal, and also reconstruct the 38kHz subcarrier to demodulate the R-L signal. For this reason, a FM stereo receiver is a a bit more complex: Flowgraph Stereo with RDS Basic receiver . Basic transmitter The transmitter in the flowgraph above expects audio to be coming in through a fifo, and listens for RDS information on TCP port 52001. HD Radio This requires additional gnuradio modules like gr-ncrs5 . Transmitter I do not have a flowgraph for a receiver. Iridium The Iridium constellation (old version, no the 'Iridium Next' generation that was launched in 2018/2019) can be received using the gr-iridium modules. OOK Modulation Example of \"On Off Keying\" modulation and how to demodulate it. https://klohner.github.io/SDR/Decoding/Example_2019-01-24/ Narrow band FM (\u201cWalkie Talkies\u201d) FRS transceiver Texas Instruments C1111 https://github.com/funoverip/gr-cc1111 ADSB reception ToDo: explain ADSB demodulation on both gnuradio (if that exists at all), and on native utilities dump1090 The dump1090 is the best known utility to receive ADS-B frames from planes and helicopters. It was originally created as a quick hack and abandonned by its creator, then taken over by a couple of other people, before finding a home with Flight Aware who are maintaining the most up to date version these days (2019.04). dump1090 works great on a Raspberry Pi, and the best way to install it is to clone the github repository, and build the debian package from there. BladeRF Micro support: I have opened a pull request to add support for the BladeRF micro. Note that the BladeRF micro does not seem to work nearly as well as the bespoke rtl-sdr based orange dongle of Flight Aware, I might need to spend more time working at the gain settings for that device. In theory it should be able to work as well as RTL-SDR dongles, especially if used with a LNA. GPS/GNSS Receiving There are several packages available out there to do GNSS demodulation. The most advanced is the creatively-named 'gnss-sdr' package available on github . MacOS support notes for gnss-sdr 2019.04: gnss-sdr is avaible on MacPort but on an outdated version that basically crashes with any current SDR (rtlsdr/osmocom). it is possible to build on MacOS though, using the current version of GNURadio installed through Macports. There are good build instructions available on the main github README.md page for gnss-sdr which you should follow. Don't forget to add \"cmake -DENABLE_OSMOSDR=ON ..\" if you want OsmoSDR support (BladeRF, RTL-SDR etc). CAREFUL: be sure you do not have a lingering version of gnss-sdr installed through a package manager when you are trying to build from source, since it will usually make compilation fail. In particular, volk will leave a \"volk_gnss\" include path on the package manager paths ( /opt/local/include for macports) that will mess up compilation, you might have to delete by hand. Also, make sure that in case you have an old homebrew install on /usr/local , none of the libraries gnss-sdr relies on are found on that path (check out the output of the cmake step). Testing Once everything is installed (installing from a source compilation does to /usr/local by default), you can follow the tutorial on the gnss-sdr website and download the test file. It should decode without issues. Frontends The Configurations page on the gnss-sdr website does a good job explaining how to configure a couple of frontends. As the main site mentions, be sure you use an active antenna - use a bias Tee if necessary - since the GPS signal is usually below the sensitivity level of most SDRs. BladeRF Micro configuration It appears that the BladeRF micro as it stands today cannot really receive GPS without external help: https://www.nuand.com/forums/viewtopic.php?t=4984 . Don't waste your time if you have other options. RTLSDR configuration Sending Careful: do not blindly broadcast your own GPS signals, this is illegal, and will lead to very serious trouble if you get caught doing this. gps-sdr-sim Available on github , it seems to be the reference. The current version as of 2019 works very well, and will accept 10Hz NMEA input as well as a couple or other formats, and is easy to extend. It is also compatible with multiple frontends and I have tested it with success on URSP SDRs. A great way to test this is to feed the generated \".bin\" file to gnss-sdr. Bluetooth WiFi Investigating unknown signals Using URH Writing a bitstream processor","title":"Experiments in software radio"},{"location":"#experiments-in-software-radio","text":"","title":"Experiments in software radio"},{"location":"#preamble","text":"THESE ARE MY OWN NOTES AFTER WORKING WITH GNURADIO FOR A WHILE, NO PROMISE OF ANY FITNESS FOR ANY PARTICULAR PURPOSE. A lot of those flowgraphs are my own, some are adapted/copied from various sources online. If you recognize your work and think it is missing attribution, please reach out and I will add proper credit where it's due. I simply haven't tracked down all my sources as I went along...","title":"Preamble"},{"location":"#introduction","text":"GNURadio is an amazing framework for all things related radio digital signal processing, and it is as powerful as it is daunting: it is a fairly venerable project started in 2001, and has always been a real adventure to install on any computer. The main gnuradio documentation, maintained on wiki.gnuradio.org, will usually help, but it is all in all fairly sparse and often quite arcane. There is a lot of material out there about GNURadio, with varying degrees of relevance, accuracy, compatibility with the current versions of GNURadio. This guide is an attempt at covering most of the basics of building GNURadio flowgraphs to process most common radio modulations, along with examples of more advanced software, often based on GNURadio, designed to fully demodulate various categories of radio signals. A common challenge for many newcomers is that GNURadio is before anything else a digital signal processing framework: despite the 'Lego'-like approach of building flowgraphs on GNURadio Companion, you will always be very limited in what you can achieve without proper understanding of the fundamentals of digital signal processing. There are a lot of excellent resources on the web for learning this (see the links section below), as well as many university courses, and if you are seriously planning to use GNURadio for real projects, learning - or taking a refresher on - digital signal processing is really a must. This guide is an attempt at getting you up and running on GNURadio as of early 2019, and introduce you to the basic building blocks of the framework, so that you can in turn use GNURadio for your own projects. Last, this guide is heavily biased towards MacOS, and everything in here is working with GNURadio version 3.7.14. YMMV.","title":"Introduction"},{"location":"#links","text":"A lot of the material in the following links is useful for learning not only about GNURadio, but also about digital signal processing. Introduction to quadrature signals by dspguru . An excellent and approachable paper. balint256 YouTube channel . The GNURadio video tutorial there is outdated, but contains a lot of great fundamentals, definitely worth a watch. http://complextoreal.com/tutorials/","title":"Links"},{"location":"#variants-of-gnuradio-mainnextetc","text":"GNURadio uses a concept of \"gnuradio\" and \"gnuradio-next\" for its stable and development branches. The stable branch is usually the way to go.","title":"Variants of GNURadio - main/next/etc"},{"location":"#installing-gnuradio","text":"https://wiki.gnuradio.org/index.php/InstallingGR is the official documentation. Below are my own notes on how to actually get it to work As of early 2020, the only version of GNURadio that is \"easy\" to install and compatible with most 3rd party modules is 3.7, despite the fact that 3.8 was released mid-2019. This is changing relatively rapidly though, so double-check.","title":"Installing GNURadio"},{"location":"#linux","text":"Most distributions do have a gnuradio package. Be careful though, those versions are often out of date, especially the 'stable' versions. My advice is to first check out the version of GNURadio that is available on your package manager, then decide whether you want to go to the trouble of going a source code install, which is not a super trivial task. That said, GNURadio has improved that respect a lot over the years by using their own Python system they call \"PyBOMBS\". If you want to attempt a source install, follow the guide at: https://wiki.gnuradio.org/index.php/InstallingGRFromSource","title":"Linux"},{"location":"#running-in-a-linux-vm","text":"While running GNURadio inside a Linux VM works fine, you will probably encounter performance issues when using it with physical SDR radios over USB, so a native version is usually preferable.","title":"Running in a Linux VM"},{"location":"#macos","text":"MacOS does run GNURadio quite well, and has its own install page on the GNURadio wiki: https://wiki.gnuradio.org/index.php/MacInstall As with Linux, using a package manager is a good idea if the package is not too outdated. Macports is usually considered as the most stable and maintained port for GNURadio, but Homebrew has been making great progress lately, and will get you up and running quite well. As of 2019.04, my advice is to go the Macports way to install the stable version of GNURadio, it does work well and closely follows the GNURadio project releases.","title":"MacOS"},{"location":"#macos-quirks","text":"As usual with Open Source projects, there are a bunch of weird quirks for running various parts of GNURadio, in particular when using Gnuradio Companion with Qt blocks: the symptom is the UI flickering very fast. This can be easily solved though, by configuring the global settings at ~/.gnuradio/config.conf with: [qtgui] style = native If you installed GNURadio through MacPorts, you might have to explicitly tell cmake to point to /opt/local when compiling OOT (\"Out of tree\") modules: cmake -DCMAKE_INSTALL_PREFIX=/opt/local ..","title":"MacOS quirks"},{"location":"#using-pybombs","text":"Apparently, some say this is possible on MacOS X... I have not attempted this.","title":"Using PyBOMBS"},{"location":"#optimization-tricks","text":"ToDo: speak about hardware acceleration, expectations of performance, etc.","title":"Optimization tricks"},{"location":"#gnuradio-companion","text":"GNURadio companion is the graphical flow graph editor of GNURadio, and a great way to do rapid prototyping on this framework. While you will probably want to work in either C++ or Python for production usage if you intend to use the GNURadio framework for your own applications, GNURadio companion is a perfect tool for doing lab work and general signal hacking. GNURadio companion uses a graphical editor to layout GNURadio blocks and connect them together.","title":"GNURadio companion"},{"location":"#gnuradio-blocks","text":"GNURadio uses a concept of signal processing blocks. Those blocks can be written in a variety of languages, from Python to C++, with C++ implementations being usually faster than Python. There is documentation on the GNURadio wiki about writing modules, that might or might not be matching the current version of GNURadio, but will in any case provide a bit of help. ToDo: describe the blocks, what they do, etc.","title":"GNURadio blocks"},{"location":"#other-useful-utilities","text":"Those are utilities I have found really useful in working with new signals:","title":"Other useful utilities"},{"location":"#gqrx","text":"gqrx is an easy(ish) to use software defined radio receiver, that is a great tool for quickly visualizing a signal. ToDo: examples of signals and how to recognize them","title":"gqrx"},{"location":"#urh","text":"Universal Radio Hacker is a lower level tool that can be very powerful to understand digital modulations and quickly do demodulation work. It comes with excellent documentation for an Open Source project, which is a really refreshing change. ToDo: examples of demodulating a signal with URH","title":"URH"},{"location":"#macos-notes","text":"Macports does not have a URH port, but you can install all of its dependencies from macports. Then you can run it, but be sure to export CFLAGS=\"-I /opt/local/include before either doing a pip install or running from the source tree. In order to compile SDR extensions on MacOS with Macports, use the fork at https://github.com/elafargue/urh which supports that distribution. ToDo: URH tutorial","title":"MacOS notes"},{"location":"#inspectrum","text":"Inspectrum is similar to URH but written in C++. It is fairly simple to build and is a good addition to any signal processing toolbox.","title":"Inspectrum"},{"location":"#sdr-setups","text":"","title":"SDR setups"},{"location":"#rtl-sdr","text":"Support for the RTL-SDR family on GNURadio is done through the gr-osmosdr module.","title":"rtl-sdr"},{"location":"#usrp","text":"USRP is extremely well supported by GNURadio, of course. the uhd Macports module implements this.","title":"USRP"},{"location":"#osmocom-bladerf","text":"","title":"osmocom / BladeRF"},{"location":"#simple-analog-operations","text":"","title":"Simple analog operations"},{"location":"#fm-demodulation","text":"FM demodulation is fairly simple: a FM-modulated signal is a carrier whose frequency varies proportionnal to the signal that we want to transmit. See wikipedia for the basics. From a Gnuradio companion perspective, it is very simple to represent in a flowgraph: Flowgraph file is here . This is a good first example, because it covers the very basics of what digital signal processing of radio signals is about. A great introduction to this, in case you do not yet understand the principle of working with in-phase and quadrature (aka IQ) signal components, is the introduction by dspguru .","title":"FM Demodulation"},{"location":"#am-demodulation","text":"AM demodulation is similar: an AM-modulated signal is also a carrier, but this time the amplitude of this carrier varies along with the signal we want to transmit. We can simply demodulate this signal by detecting the envelope of the received signal: The most basic GNURadio flowgraph for this would be as follows: Flowgraph file is here . note: this refers to the example data file available at the excellent course at: http://www.csun.edu/~skatz/katzpage/sdr_project/ . You should look up this site to learn more able AM and SSB in relation to digital radio.","title":"AM Demodulation"},{"location":"#ssb-demodulation","text":"Single side band is an energy-efficient variant of amplitude modulation. Essentially, it is AM modulation with the carrier suppressed, and only one of the sidebands transmitted. It is not difficult to modulate, but demodulating it is slightly more complex. There are a couple of DSP algorithms out there for doing this, but Weaver is by far the most popular because it is very well suited to software defined radio. Reference links: Very good overview of SSB demodulation techniques Course on Weaver demodulation with clear explanation of the technique (todo: insert flowgraph of my own SSB receiver) Flowgraph file is here","title":"SSB Demodulation"},{"location":"#analog-and-digital-video","text":"Quick side note on video: there is a great utility that works with \"Tempest\" radiated transmission on video signals (TODO: more background on Tempest): TempestSDR, which works great with the USRP. TempestSDR . Works great on the Mac. You will need to patch a couple of things to make it run, but nothing bad: --- a/TSDRPlugin_UHD/src/TSDRPlugin_UHD.cpp +++ b/TSDRPlugin_UHD/src/TSDRPlugin_UHD.cpp @@ -14,7 +14,7 @@ #include <stdlib.h> #include <string.h> -#include <uhd/utils/thread_priority.hpp> +#include <uhd/utils/thread.hpp> #include <uhd/utils/safe_main.hpp> #include <uhd/usrp/multi_usrp.hpp> #include <uhd/transport/udp_simple.hpp> @@ -332,7 +332,7 @@ EXTERNC TSDRPLUGIN_API int __stdcall tsdrplugin_readasync(tsdrplugin_readasync_f // flush usrpbuffer while(rx_stream->recv( buff, samples_per_api_read, md, - uhd::device::RECV_MODE_ONE_PACKET + true )){ /* NOP */ };","title":"Analog and digital video"},{"location":"#digital-operations","text":"Nowadays, radio signals are often used to transmit bits rather than analog information. This section covers some common techniques used for doing this.","title":"Digital operations"},{"location":"#basics-of-digital-operations","text":"Digital signals are usually modulated using a combination of the amplitude, frequency and phase of a signal. To make demodulation easier, binary data is often encapsulated into frames that usually contain: A start sequence, used by the demodulator to synchronise itself to the incoming bitstream Some sort of header that contains the expected length of the frame Error correcting codes, either throughout or at the end of the frame. Digital to analogue conversion, besides modulating a bitstream using Amplitude/Frequency/Phase or a combination of all of these, also uses a notion of \"symbols\": instead of doing a one-to-one conversion of a \"0\" or \"1\" into two discrete analogue signal states, a lot of modulation schemes take longer bit sequences, such as \"00\" \"01\" \"10\" \"11\" and turn them into multiple discrete analogue signal states. Those sequences are called \"symbols\" and allow increasing the density of information that is sent inside of each modulation state. A demodulator therefore needs to do the following on an incoming analog signal: Demodulate the raw analogue signal to turn it in to a \"clean\" analogue signal with clear discrete states Turn that demodulated analogue signal into a symbols by knowing exactly when to sample the signal state to map it to symbols. This is called \"clock recovery\" Remap the symbols to bit values Find start sequences in the bitstream to get in sync Recover packet length \"Deframe\" the packet and check its CRC GNURadio provides a lot of blocks to do almost all of these operations, but start sequence detection and deframing is usually quite specific to each modulation type, and there is only a limited number of off the shelf blocks that can be used for this. You will often need to get into python - or C - and write your own blocks for those. The next couple of sections provide more details on some of the aspects of demodulation using GNURadio. From a more tactical perspective, what you will usually find in a flowgraph is the following: Analogue signal reception from SDR Low Pass / frequency translate to center the signal around zero hertz Analogue demodulate Clock Recovery Bitstream decoding (NRZ, Manchester, inversion, etc) Bitstream deframing The analogue part was covered to some extent in some of the basic receivers above.","title":"Basics of digital operations"},{"location":"#clock-recovery","text":"Clock recovery is essentially a process that decides when the analogue signal should be sampled to determine the symbol state. When it works well, clock recovery will sample exactly once per transmitted symbol. GNURadio provides several good clock recovery blocks in the \"Synchronizers\" category. Some of the blocks that are easier to use are: Clock Recovery MM Polyphase Clock Sync With those blocks, you will need to know the symbol rate and bitrate in advance, so that they can make the right decision for sampling the symbols. The AFSK AX25 decoder flow graph below is a good example of using the Polyphase Clock Sync or the Clock Recovery MM blocks.","title":"Clock recovery"},{"location":"#processing-bitstreams","text":"","title":"Processing bitstreams"},{"location":"#ook-ask","text":"This is one of the simplest kinds of digital modulation: a carrier that is simply turned on/off to transmit information, hence the \"OOK\" (On-Off keying) or \"ASK\" (Amplitude Shift Keying) acronyms.","title":"OOK / ASK"},{"location":"#useful-demodulators","text":"rtl_433 is a great general purpose demodulator and decoder for OOK signals, and is able to decode more than a hundred types of simple sensors, from wireless alarm sensors to a bunch of weather sensors. rtlamr An rtl-sdr receiver for Itron ERT compatible smart meters operating in the 900MHz ISM band.","title":"Useful demodulators"},{"location":"#frequency-shift-keying","text":"Frequency Shift Keying, or \"FSK\", uses discrete frequency changes of a carrier signal for modulating a bitstream. The simplest FSk uses two frequencies, one for \"0\" and one for \"1\", but it is also possible to use a larger number of discrete frequencies to encode longer symbols - for example \"00\", \"01\", \"10\" and \"11\" can be transmitted using 4-FSK, i.e. four separate frequencies. FSK is usually demodulated using quadrature demodulation. Note that a FSK-modulated signal can be transmitted as a carrier changing over N frequencies (usually within a couple of hundred hertz of each other), or through discrete frequency changes of a signal that is FM or AM modulated. In the latter case, we usually talk about \"AFSK\", or \"Audio FSK\". Other kinds of FSK exist that were designed to improve specific aspects of this sort of modulation, such as power efficiciency. The wikipedia article on FSK is a nice introduction and easy to understand.","title":"Frequency shift keying"},{"location":"#links_1","text":"https://github.com/handiko/gr-APRS A great tutorial: http://aaronscher.com/GNU_Radio_Companion_Collection/Audio_Modem_loop_back_test_FSK.html Another one: https://nccgroup.github.io/RFTM/fsk_receiver.html","title":"Links"},{"location":"#2-afsk","text":"The easiest way to demodulate a FSK transmission is to use a Quadrature demodulation block: the output of quadrature demodulation varies with the phase change that occurs at frequency transition between the FSK frequencies, so this is a good way to turn the signal into symbol states. Since 2-FSK uses only 2 frequencies, there is usually a direct mapping of the frequency to either a \"0\" or \"1\" value, though you have to keep in mind that the signal is often encoded for robustness and energy efficiency using differential or Manchester encoding. The sample AX25 receiver included in this repository is a great example of 2-AFSK reception. You can use this flowgraph and adapt it to other types of modulation fairly easily: Adjust the FSK deviation of the signal Adjust the birate Adjust the bitstream decoding after the binary slicer Note: as you can see on the flowgraph below, we are doing two demodulations. You have to keep in mind that FM modulation of an analogue signal modulates the carrier signal by an amount that is proportional to the original analogue signal, but multiplied by a \"modulation index\". For this reason, it is not possible to simply convert a FM-modulated signal into a FSK bitstream, you first need to demodulate the FM signal into the deviation-correct FSK analogue modulation, then demodulate that signal into a bitstream. Another equivalent way to look at is is that AX25 is transmitted over narrow-band HAM radio, so the flowgraph first demodulates the FM signal into an audio signal, then it does the actual Audio FSK (aka AFSK) demodulation. GRC Flowgraph code","title":"2-AFSK"},{"location":"#2-fsk","text":"A good example of a 2-FSK signal is the old school \"RTTY\" modulation","title":"2-FSK"},{"location":"#n-fsk","text":"","title":"N-FSK"},{"location":"#links_2","text":"http://qradiolink.org/4fsk-viterbi-soft-symbol-decoding.html","title":"Links"},{"location":"#phase-shift-keying","text":"","title":"Phase shift keying"},{"location":"#ofdm","text":"","title":"OFDM"},{"location":"#real-world-examples","text":"","title":"Real world examples"},{"location":"#broadcast-fm","text":"Broadcast FM is kind of a \"Hello World\" of radio reception on GNURadio, the below flowgraphs are a good example of making your first steps with it. The main difference between \"Broadcast FM\" compared to just \"FM\" modulation is the following: Broadcast FM uses a standardized frequency deviation, usually with a maximum of 75kHz Pre-emphasis is applied to the signal to offset the effect of band noise Modern FM usually is broadcast in stereo (see below or Wikipedia for details) More and more, digital information is included in the broadcast (data, audio, or both)","title":"Broadcast FM"},{"location":"#mono","text":"A Broadcast mono FM receiver is really a standard FM receiver with standard deviation and de-emphasis applied. It is identical to the flowgraph shown above on basic FM reception: Flowgraph","title":"Mono"},{"location":"#stereo","text":"Stereo signals are transmitted at a set of two channels: the \"R+L\" channels at baseband audio frequency, and \"R-L\" centered on 38kHz higher. This makes them compatible with mono receivers that will just demodulate the R+L component. A 19kHz pilot tone is also added to help receivers detect the presence of a stereo signal, and also reconstruct the 38kHz subcarrier to demodulate the R-L signal. For this reason, a FM stereo receiver is a a bit more complex: Flowgraph","title":"Stereo"},{"location":"#stereo-with-rds","text":"Basic receiver . Basic transmitter The transmitter in the flowgraph above expects audio to be coming in through a fifo, and listens for RDS information on TCP port 52001.","title":"Stereo with RDS"},{"location":"#hd-radio","text":"This requires additional gnuradio modules like gr-ncrs5 . Transmitter I do not have a flowgraph for a receiver.","title":"HD Radio"},{"location":"#iridium","text":"The Iridium constellation (old version, no the 'Iridium Next' generation that was launched in 2018/2019) can be received using the gr-iridium modules.","title":"Iridium"},{"location":"#ook-modulation","text":"Example of \"On Off Keying\" modulation and how to demodulate it. https://klohner.github.io/SDR/Decoding/Example_2019-01-24/","title":"OOK Modulation"},{"location":"#narrow-band-fm-walkie-talkies","text":"","title":"Narrow band FM (\u201cWalkie Talkies\u201d)"},{"location":"#frs-transceiver","text":"","title":"FRS transceiver"},{"location":"#texas-instruments-c1111","text":"https://github.com/funoverip/gr-cc1111","title":"Texas Instruments C1111"},{"location":"#adsb-reception","text":"ToDo: explain ADSB demodulation on both gnuradio (if that exists at all), and on native utilities","title":"ADSB reception"},{"location":"#dump1090","text":"The dump1090 is the best known utility to receive ADS-B frames from planes and helicopters. It was originally created as a quick hack and abandonned by its creator, then taken over by a couple of other people, before finding a home with Flight Aware who are maintaining the most up to date version these days (2019.04). dump1090 works great on a Raspberry Pi, and the best way to install it is to clone the github repository, and build the debian package from there. BladeRF Micro support: I have opened a pull request to add support for the BladeRF micro. Note that the BladeRF micro does not seem to work nearly as well as the bespoke rtl-sdr based orange dongle of Flight Aware, I might need to spend more time working at the gain settings for that device. In theory it should be able to work as well as RTL-SDR dongles, especially if used with a LNA.","title":"dump1090"},{"location":"#gpsgnss","text":"","title":"GPS/GNSS"},{"location":"#receiving","text":"There are several packages available out there to do GNSS demodulation. The most advanced is the creatively-named 'gnss-sdr' package available on github .","title":"Receiving"},{"location":"#macos-support-notes-for-gnss-sdr","text":"2019.04: gnss-sdr is avaible on MacPort but on an outdated version that basically crashes with any current SDR (rtlsdr/osmocom). it is possible to build on MacOS though, using the current version of GNURadio installed through Macports. There are good build instructions available on the main github README.md page for gnss-sdr which you should follow. Don't forget to add \"cmake -DENABLE_OSMOSDR=ON ..\" if you want OsmoSDR support (BladeRF, RTL-SDR etc). CAREFUL: be sure you do not have a lingering version of gnss-sdr installed through a package manager when you are trying to build from source, since it will usually make compilation fail. In particular, volk will leave a \"volk_gnss\" include path on the package manager paths ( /opt/local/include for macports) that will mess up compilation, you might have to delete by hand. Also, make sure that in case you have an old homebrew install on /usr/local , none of the libraries gnss-sdr relies on are found on that path (check out the output of the cmake step).","title":"MacOS support notes for gnss-sdr"},{"location":"#testing","text":"Once everything is installed (installing from a source compilation does to /usr/local by default), you can follow the tutorial on the gnss-sdr website and download the test file. It should decode without issues.","title":"Testing"},{"location":"#frontends","text":"The Configurations page on the gnss-sdr website does a good job explaining how to configure a couple of frontends. As the main site mentions, be sure you use an active antenna - use a bias Tee if necessary - since the GPS signal is usually below the sensitivity level of most SDRs.","title":"Frontends"},{"location":"#bladerf-micro-configuration","text":"It appears that the BladeRF micro as it stands today cannot really receive GPS without external help: https://www.nuand.com/forums/viewtopic.php?t=4984 . Don't waste your time if you have other options.","title":"BladeRF Micro configuration"},{"location":"#rtlsdr-configuration","text":"","title":"RTLSDR configuration"},{"location":"#sending","text":"Careful: do not blindly broadcast your own GPS signals, this is illegal, and will lead to very serious trouble if you get caught doing this.","title":"Sending"},{"location":"#gps-sdr-sim","text":"Available on github , it seems to be the reference. The current version as of 2019 works very well, and will accept 10Hz NMEA input as well as a couple or other formats, and is easy to extend. It is also compatible with multiple frontends and I have tested it with success on URSP SDRs. A great way to test this is to feed the generated \".bin\" file to gnss-sdr.","title":"gps-sdr-sim"},{"location":"#bluetooth","text":"","title":"Bluetooth"},{"location":"#wifi","text":"","title":"WiFi"},{"location":"#investigating-unknown-signals","text":"","title":"Investigating unknown signals"},{"location":"#using-urh","text":"","title":"Using URH"},{"location":"#writing-a-bitstream-processor","text":"","title":"Writing a bitstream processor"},{"location":"examples/fsk/","text":"Unknown FSK signal Example 1 - 2-FSK Restaurant pager You can open this file in URH, and use the (i) dialog to set the sample rate (good practice so that the timings are displayed accurately). Zooming in on the signal shows that we are dealing with multiple frequencies, which is a hint of a couple of things: It might be FSK The recording might contain both a signal and harmonics - possibly caused by a SDR frontend overload We can qualify this by picking the spectrogram view and zoom in: Zooming in further, it's clear that the horizontal lines are just the same signal appearing multiple times (and mirrored), which is typical of the SDR receiver being overloaded, so let's just select the strongest signal and isolate it: The spectrogram view also shows clearly the presence of two different frequencies in the signal, so we're looking at a 2-tone FSK. Once the signal is isolated, we can try to do an autodetect in FSK mode - since the signal is now filtered and its sampling rate is high, autodetect works well this time around: Like with other sampled signals, it's obvious we have a long preamble to help the receiver synchronize, then a series of 0's and 1's. The demodulated view is fairly clean and by now it's clear we have a typical FSK signal with two tones. We can also look at the average length of a bit, and we find something around 800\u00b5s to 900\u00b5s, which would be consistent with a 1200bps rate which is classic. In order to recover the value of the message, we need to zoom in on the end of the preample and determine the first bit of the payload. For this particular protocol, there is no pause between the end of the preamble and the bitstream, so the message most probably starts at the first bit that breaks the 01010101 sequence: Moving to the \"Analysis\" screen, we can align the decoder by selecting the first 8 bits after the preamble and labeling those. This will force URH to align its decoding when translating to hexadecimal: Switching back to hex format, we can see that the first byte is 0x83 - and that the sequence of 0xaa was not perfectly aligned on multiples of 8 bits, so it was useful to create this label. If we switch back to the \"Interpretation\" screen and click on the demodulated graph again, this will trigger a re-demodulation of the bitstream and the correct bitstream value will be updated in the hex dump: The message seems to be this: 832dea27 c9a4abfa 85763e68 85763e68 85763e68 85763e68 Now, we need to make sense of it. In wireless protocols, besides preambles that are used to wake up receivers and help them sync their clocks, another pattern is often used to synchronize receivers: sync words/patterns. This is a special pattern that normally doesn't happen in the payload of wireless messages, and that receivers detect in order to align the decoding of the bitstream. Since the message contains a multiple of 4-byte sequences, there is a good chance the sync pattern is 0x832dea27. At this point, unless you already have your own database of known sync words, a duckduckgo search is a good way to make progresss. 0x832dea27 sync pattern is a good search, but... it does not return anything. Going back to the \"Analysis\" screen, we can try to change the \"Decoding\" dropdown to NRZ + Invert . After all, there's no strict convention on what frequency should be a \"1\" and which should be a \"0\", so we invert the convention and see if that leads us somewhere. The - presumed - sync pattern is now demodulated as 0x7cd215d8 . And a 0x7cd215d8 sync pattern immediately tells us that this is the pattern for... the POCSAG pager protocol! This makes complete sense since this capture was from a restaurant pager. We can therefore update the decoded stream with the inverted values (this time we must copy from the \"Analysis\" screen, since the \"Interpretation\" screen does not reflect decoding options and defaults to NRZ only). And we can actually decode the meaning using details on the protocol 7cd215d8 - Sync word 365b5405 - Message 7a89c197 - Idle frame 7a89c197 - Idle frame 7a89c197 - Idle frame 7a89c197 - Idle frame Decoding POCSAG is a job of its own, but fortunately, tools like multimod-ng can do this very well: you now have all you need to transform the raw IQ file into a WAV file demodulated into narrow FM mode which will give you an audio FSK file with the two tones, you use gqrx to do this. Then play the resulting wav file into multimon-ng: ./multimon-ng -t wav -a POCSAG1200 ../../gqrx_20220821_193850_315598200.wav multimon-ng 1.2.0 (C) 1996/1997 by Tom Sailer HB9JNX/AE4WA (C) 2012-2022 by Elias Oenal Available demodulators: POCSAG512 POCSAG1200 POCSAG2400 FLEX FLEX_NEXT EAS UFSK1200 CLIPFSK FMSFSK AFSK1200 AFSK2400 AFSK2400_2 AFSK2400_3 HAPN4800 FSK9600 DTMF ZVEI1 ZVEI2 ZVEI3 DZVEI PZVEI EEA EIA CCIR MORSE_CW DUMPCSV X10 SCOPE Enabled demodulators: POCSAG1200 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 899706 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 sox WARN rate: rate clipped 5815 samples; decrease volume? sox WARN dither: dither clipped 5090 samples; decrease volume? POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 1618195 Function: 2 POCSAG1200: Address: 890576 Function: 2","title":"Unknown FSK signal"},{"location":"examples/fsk/#unknown-fsk-signal","text":"","title":"Unknown FSK signal"},{"location":"examples/fsk/#example-1-2-fsk-restaurant-pager","text":"You can open this file in URH, and use the (i) dialog to set the sample rate (good practice so that the timings are displayed accurately). Zooming in on the signal shows that we are dealing with multiple frequencies, which is a hint of a couple of things: It might be FSK The recording might contain both a signal and harmonics - possibly caused by a SDR frontend overload We can qualify this by picking the spectrogram view and zoom in: Zooming in further, it's clear that the horizontal lines are just the same signal appearing multiple times (and mirrored), which is typical of the SDR receiver being overloaded, so let's just select the strongest signal and isolate it: The spectrogram view also shows clearly the presence of two different frequencies in the signal, so we're looking at a 2-tone FSK. Once the signal is isolated, we can try to do an autodetect in FSK mode - since the signal is now filtered and its sampling rate is high, autodetect works well this time around: Like with other sampled signals, it's obvious we have a long preamble to help the receiver synchronize, then a series of 0's and 1's. The demodulated view is fairly clean and by now it's clear we have a typical FSK signal with two tones. We can also look at the average length of a bit, and we find something around 800\u00b5s to 900\u00b5s, which would be consistent with a 1200bps rate which is classic. In order to recover the value of the message, we need to zoom in on the end of the preample and determine the first bit of the payload. For this particular protocol, there is no pause between the end of the preamble and the bitstream, so the message most probably starts at the first bit that breaks the 01010101 sequence: Moving to the \"Analysis\" screen, we can align the decoder by selecting the first 8 bits after the preamble and labeling those. This will force URH to align its decoding when translating to hexadecimal: Switching back to hex format, we can see that the first byte is 0x83 - and that the sequence of 0xaa was not perfectly aligned on multiples of 8 bits, so it was useful to create this label. If we switch back to the \"Interpretation\" screen and click on the demodulated graph again, this will trigger a re-demodulation of the bitstream and the correct bitstream value will be updated in the hex dump: The message seems to be this: 832dea27 c9a4abfa 85763e68 85763e68 85763e68 85763e68 Now, we need to make sense of it. In wireless protocols, besides preambles that are used to wake up receivers and help them sync their clocks, another pattern is often used to synchronize receivers: sync words/patterns. This is a special pattern that normally doesn't happen in the payload of wireless messages, and that receivers detect in order to align the decoding of the bitstream. Since the message contains a multiple of 4-byte sequences, there is a good chance the sync pattern is 0x832dea27. At this point, unless you already have your own database of known sync words, a duckduckgo search is a good way to make progresss. 0x832dea27 sync pattern is a good search, but... it does not return anything. Going back to the \"Analysis\" screen, we can try to change the \"Decoding\" dropdown to NRZ + Invert . After all, there's no strict convention on what frequency should be a \"1\" and which should be a \"0\", so we invert the convention and see if that leads us somewhere. The - presumed - sync pattern is now demodulated as 0x7cd215d8 . And a 0x7cd215d8 sync pattern immediately tells us that this is the pattern for... the POCSAG pager protocol! This makes complete sense since this capture was from a restaurant pager. We can therefore update the decoded stream with the inverted values (this time we must copy from the \"Analysis\" screen, since the \"Interpretation\" screen does not reflect decoding options and defaults to NRZ only). And we can actually decode the meaning using details on the protocol 7cd215d8 - Sync word 365b5405 - Message 7a89c197 - Idle frame 7a89c197 - Idle frame 7a89c197 - Idle frame 7a89c197 - Idle frame Decoding POCSAG is a job of its own, but fortunately, tools like multimod-ng can do this very well: you now have all you need to transform the raw IQ file into a WAV file demodulated into narrow FM mode which will give you an audio FSK file with the two tones, you use gqrx to do this. Then play the resulting wav file into multimon-ng: ./multimon-ng -t wav -a POCSAG1200 ../../gqrx_20220821_193850_315598200.wav multimon-ng 1.2.0 (C) 1996/1997 by Tom Sailer HB9JNX/AE4WA (C) 2012-2022 by Elias Oenal Available demodulators: POCSAG512 POCSAG1200 POCSAG2400 FLEX FLEX_NEXT EAS UFSK1200 CLIPFSK FMSFSK AFSK1200 AFSK2400 AFSK2400_2 AFSK2400_3 HAPN4800 FSK9600 DTMF ZVEI1 ZVEI2 ZVEI3 DZVEI PZVEI EEA EIA CCIR MORSE_CW DUMPCSV X10 SCOPE Enabled demodulators: POCSAG1200 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 899706 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 sox WARN rate: rate clipped 5815 samples; decrease volume? sox WARN dither: dither clipped 5090 samples; decrease volume? POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 890576 Function: 2 POCSAG1200: Address: 1618195 Function: 2 POCSAG1200: Address: 890576 Function: 2","title":"Example 1 - 2-FSK Restaurant pager"},{"location":"examples/ook/","text":"Unknown OOK signal Example 1 The samples/ directory contains an IQ file called OOK-gqrx_20220820_231011_314999950_1000000_fc.raw that was captured with GQRX using a RTL-SDR generic dongle. It is a bit noisy but representative of a real world capture. GQRX names the files with the frequency of the receiver and the sample rate: 314999950 Hz: ~315 MHz 1000000 bps : 1Mbit/s sampling Using URH You can open the larger file with URH and it will show you the waveform: This is typical of a basic capture where the RTL-SDR dongle gain control will overcorrect the signal which creates the irregularities. It is clear that we have three separate frames, so let's focus on the first one: select the first frame and right-click to crop the signal: Now, zooming in on the signal, you can clearly see an alternance of short bursts of varying length. This is typical of \"OOK\", or \"On-Off Keying\", where a transmitter sends a bitstream by either sending or not sending a signal at a specific frequency. \"OOK\" is also considered as the most simple type of \"ASK\" as \"Amplitude Shift Keying\", where a bitstreams 0's and 1's are either 0% signal or 100% signal. This example is intentionally very simple: there are only 2 lenghts of short and long modulations or spaces, with the long one being double of the short one. This is a very simple modulation, where a \"symbol\" will be one bit, and the symbol length is the \"short\" length. We can just select it to find out. Hint: press the (i) in the left space where you adjust the variables, and set the sampling rate to \"1M\" to reflect the correct timing if you want to work out the bitrate of your signal You can now make progress on the demodulation and set sensible parameters in the toolbar on the left based on what you have learned so far: Adjust the value of \"noise\" to have the noise on the signal be just covered by the red area Adjust the \"samples per symbol\" to 400 since this is the length of the short interval we just worked out Set error tolerance to 5% - 20 samples. No need to be too strict on short timing errors, a lot of low cost transmitters are not super accurate anyway Set modulation to ASK We will now focus on the lower half of the screen. If demodulation worked ou as we expected, then if we select the \"Signal View\" dropdown to \"demodulated\", then it will be clear that we now have a stream of \"0\" and \"1\". We can also change the display of the bitstream to \"hex\", and as you can see on the screenshot, we can see repeating patterns which is always an encouraging sign: Now, the question is whether we have actually properly decoded the message: while we clearly have a bitstream - 99.9% of the time aligned on bytes, i.e. 8 bits - , how do we know we have started the decoding of the bitstream at the first bit of the first byte> The answer to this, in the vast majority of the cases, lies in the very start of the message: radio receivers also need to know the alignement, and most radio protocols include a 'preamble' to that effect. A classic preamble can be a series of 0's and 1's. Let's zoom in on the signal: The preamble is clearly visible here, and you can also notice that the space between the end of the preamble and the start of the message is 1200\u00b5s - 400\u00b5s * 3. This is also a classic pattern on radio protocols to help the receiver not only detect the start of the message, but also calibrate the bitrate on the series of 0's and 1's. This allows the use of cheap transmitters and receivers with imprecise clocks with high tolerance, where they use the preamble to align their clock rates to each other - and is also why we set the tolerance to 5% above, to account for this. The 0b10101010 pattern translates to 0xaa in hexadecimal, which is what we see in the hex dump in the URH window as well (see screenshot above). But the hex dump starts with \"2\", which is a glitch caused by the initial spike. We can therefore delete the unwanted glitch in the signal to start the decoding at the beginning of the preamble - or at the first bit after the preamble: And here we have it: the decoded bitstream now starts with 0xaa and we can see the repeated patterns: aaaaaa8acb32cccccb4d2d4ad34cab4b1596659999969a5a95a69956962b2ccb33332d34b52b4d32ad28 aaaaaa8acb32cccccb4d2d4ad34cab4b1596659999969a5a95a69956962b2ccb33332d34b52b4d32ad28 aaaaaa8acb32cccccb4d2d4ad34cab4b1596659999969a5a95a69956962b2ccb33332d34b52b4d32ad28 aaaaaa8acb32cccccb4d2d4ad34cab4b1596659999969a5a95a69956962b2ccb33332d34b52b4d32ad28 aaaaaa8acb32cccccb4d2d4ad34cab4b1596659999969a5a95a69956962b2ccb33332d34b52b4d32ad28 aaaaaa8acb32cccccb4d2d4ad34cab4b1596659999969a5a95a69956962b2ccb33332d34b52b4d32ad28 aaaaaa8acb32cccccb4d2d4ad34cab4b1596659999969a5a95a69956962b2ccb33332d34b52b4d32ad28 aaaaaa8acb32cccccb4d2d4ad34cab4b1596659999969a5a95a69956962b2ccb33332d34b52b4d32ad28 aaaaaa8acb32cccccb4d2d4ad34cab4b1596659999969a5a95a69956962b2ccb33332d34b52b4d32ad28 aaaaaa8acb32cccccb4d2d4ad34cab4b1596659999969a5a95a69956962b2ccb33332d34b52b4d32ad28 [Pause: 84909 samples] I will leave that this means as an exercise to the reader - don't waste too much time on it though, this is just a basic remote control message with a long bit pattern that has no special meaning besides \"open\".","title":"Unknown OOK signal"},{"location":"examples/ook/#unknown-ook-signal","text":"","title":"Unknown OOK signal"},{"location":"examples/ook/#example-1","text":"The samples/ directory contains an IQ file called OOK-gqrx_20220820_231011_314999950_1000000_fc.raw that was captured with GQRX using a RTL-SDR generic dongle. It is a bit noisy but representative of a real world capture. GQRX names the files with the frequency of the receiver and the sample rate: 314999950 Hz: ~315 MHz 1000000 bps : 1Mbit/s sampling","title":"Example 1"},{"location":"examples/ook/#using-urh","text":"You can open the larger file with URH and it will show you the waveform: This is typical of a basic capture where the RTL-SDR dongle gain control will overcorrect the signal which creates the irregularities. It is clear that we have three separate frames, so let's focus on the first one: select the first frame and right-click to crop the signal: Now, zooming in on the signal, you can clearly see an alternance of short bursts of varying length. This is typical of \"OOK\", or \"On-Off Keying\", where a transmitter sends a bitstream by either sending or not sending a signal at a specific frequency. \"OOK\" is also considered as the most simple type of \"ASK\" as \"Amplitude Shift Keying\", where a bitstreams 0's and 1's are either 0% signal or 100% signal. This example is intentionally very simple: there are only 2 lenghts of short and long modulations or spaces, with the long one being double of the short one. This is a very simple modulation, where a \"symbol\" will be one bit, and the symbol length is the \"short\" length. We can just select it to find out. Hint: press the (i) in the left space where you adjust the variables, and set the sampling rate to \"1M\" to reflect the correct timing if you want to work out the bitrate of your signal You can now make progress on the demodulation and set sensible parameters in the toolbar on the left based on what you have learned so far: Adjust the value of \"noise\" to have the noise on the signal be just covered by the red area Adjust the \"samples per symbol\" to 400 since this is the length of the short interval we just worked out Set error tolerance to 5% - 20 samples. No need to be too strict on short timing errors, a lot of low cost transmitters are not super accurate anyway Set modulation to ASK We will now focus on the lower half of the screen. If demodulation worked ou as we expected, then if we select the \"Signal View\" dropdown to \"demodulated\", then it will be clear that we now have a stream of \"0\" and \"1\". We can also change the display of the bitstream to \"hex\", and as you can see on the screenshot, we can see repeating patterns which is always an encouraging sign: Now, the question is whether we have actually properly decoded the message: while we clearly have a bitstream - 99.9% of the time aligned on bytes, i.e. 8 bits - , how do we know we have started the decoding of the bitstream at the first bit of the first byte> The answer to this, in the vast majority of the cases, lies in the very start of the message: radio receivers also need to know the alignement, and most radio protocols include a 'preamble' to that effect. A classic preamble can be a series of 0's and 1's. Let's zoom in on the signal: The preamble is clearly visible here, and you can also notice that the space between the end of the preamble and the start of the message is 1200\u00b5s - 400\u00b5s * 3. This is also a classic pattern on radio protocols to help the receiver not only detect the start of the message, but also calibrate the bitrate on the series of 0's and 1's. This allows the use of cheap transmitters and receivers with imprecise clocks with high tolerance, where they use the preamble to align their clock rates to each other - and is also why we set the tolerance to 5% above, to account for this. The 0b10101010 pattern translates to 0xaa in hexadecimal, which is what we see in the hex dump in the URH window as well (see screenshot above). But the hex dump starts with \"2\", which is a glitch caused by the initial spike. We can therefore delete the unwanted glitch in the signal to start the decoding at the beginning of the preamble - or at the first bit after the preamble: And here we have it: the decoded bitstream now starts with 0xaa and we can see the repeated patterns: aaaaaa8acb32cccccb4d2d4ad34cab4b1596659999969a5a95a69956962b2ccb33332d34b52b4d32ad28 aaaaaa8acb32cccccb4d2d4ad34cab4b1596659999969a5a95a69956962b2ccb33332d34b52b4d32ad28 aaaaaa8acb32cccccb4d2d4ad34cab4b1596659999969a5a95a69956962b2ccb33332d34b52b4d32ad28 aaaaaa8acb32cccccb4d2d4ad34cab4b1596659999969a5a95a69956962b2ccb33332d34b52b4d32ad28 aaaaaa8acb32cccccb4d2d4ad34cab4b1596659999969a5a95a69956962b2ccb33332d34b52b4d32ad28 aaaaaa8acb32cccccb4d2d4ad34cab4b1596659999969a5a95a69956962b2ccb33332d34b52b4d32ad28 aaaaaa8acb32cccccb4d2d4ad34cab4b1596659999969a5a95a69956962b2ccb33332d34b52b4d32ad28 aaaaaa8acb32cccccb4d2d4ad34cab4b1596659999969a5a95a69956962b2ccb33332d34b52b4d32ad28 aaaaaa8acb32cccccb4d2d4ad34cab4b1596659999969a5a95a69956962b2ccb33332d34b52b4d32ad28 aaaaaa8acb32cccccb4d2d4ad34cab4b1596659999969a5a95a69956962b2ccb33332d34b52b4d32ad28 [Pause: 84909 samples] I will leave that this means as an exercise to the reader - don't waste too much time on it though, this is just a basic remote control message with a long bit pattern that has no special meaning besides \"open\".","title":"Using URH"}]}