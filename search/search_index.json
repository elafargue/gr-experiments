{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Gnuradio, yet another guide Preamble GNURadio is an amazing framework for all things related radio digital signal processing, and it is as powerful as it is daunting: it is a fairly venerable project started in 2001, and has always been a real adventure to install on any computer. The main gnuradio documentation, maintained on wiki.gnuradio.org, will usually help, but it is all in all fairly sparse and often quite arcane. There is a lot of material out there about GNURadio, with varying degrees of relevance, accuracy, compatibility with the current versions of GNURadio. This guide is an attempt at covering most of the basics of building GNURadio flowgraphs to process most common radio modulations, along with examples of more advanced software, often based on GNURadio, designed to fully demodulate various categories of radio signals. A common challenge for many newcomers is that GNURadio is before anything else a digital signal processing framework: despite the 'Lego'-like approach of building flowgraphs on GNURadio Companion, you will always be very limited in what you can achieve without proper understanding of the fundamentals of digital signal processing. There are a lot of excellent resources on the web for learning this (see the links section below), as well as many university courses, and if you are seriously planning to use GNURadio for real projects, learning - or taking a refresher on - digital signal processing is really a must. This guide is an attempt at getting you up and running on GNURadio as of early 2019, and introduce you to the basic building blocks of the framework, so that you can in turn use GNURadio for your own projects. Last, this guide is heavily biased towards MacOS, and everything in here is working with GNURadio version 3.7.14. YMMV. Links A lot of the material in the following links is useful for learning not only about GNURadio, but also about digital signal processing. Introduction to quadrature signals by dspguru . An excellent and approachable paper. balint256 YouTube channel . The GNURadio video tutorial there is outdated, but contains a lot of great fundamentals, definitely worth a watch. http://complextoreal.com/tutorials/ Variants of GNURadio - main/next/etc GNURadio uses a concept of \"gnuradio\" and \"gnuradio-next\" for its stable and development branches. The stable branch is usually the way to go. Installing GNURadio https://wiki.gnuradio.org/index.php/InstallingGR is the official documentation. Below are my own notes on how to actually get it to work Linux Most distributions do have a gnuradio package. Be careful though, those versions are often out of date, especially the 'stable' versions. My advice is to first check out the version of GNURadio that is available on your package manager, then decide whether you want to go to the trouble of going a source code install, which is not a super trivial task. That said, GNURadio has improved that respect a lot over the years by using their own Python system they call \"PyBOMBS\". If you want to attempt a source install, follow the guide at: https://wiki.gnuradio.org/index.php/InstallingGRFromSource Running in a Linux VM While running GNURadio inside a Linux VM works fine, you will probably encounter performance issues when using it with physical SDR radios over USB, so a native version is usually preferable. MacOS MacOS does run GNURadio quite well, and has its own install page on the GNURadio wiki: https://wiki.gnuradio.org/index.php/MacInstall As with Linux, using a package manager is a good idea if the package is not too outdated. Macports is usually considered as the most stable and maintained port for GNURadio, but Homebrew has been making great progress lately, and will get you up and running quite well. As of 2019.04, my advice is to go the Macports way to install the stable version of GNURadio, it does work well and closely follows the GNURadio project releases. MacOS quirks As usual with Open Source projects, there are a bunch of weird quirks for running various parts of GNURadio, in particular when using Gnuradio Companion with Qt blocks: the symptom is the UI flickering very fast. This can be easily solved though, by configuring the global settings at ~/.gnuradio/config.conf with: [qtgui] style = native If you installed GNURadio through MacPorts, you might have to explicitly tell cmake to point to /opt/local when compiling OOT (\"Out of tree\") modules: cmake -DCMAKE_INSTALL_PREFIX=/opt/local .. Using PyBOMBS Apparently, some say this is possible on MacOS X... I have not attempted this. Optimization tricks ToDo: speak about hardware acceleration, expectations of performance, etc. GNURadio companion GNURadio companion is the graphical flow graph editor of GNURadio, and a great way to do rapid prototyping on this framework. While you will probably want to work in either C++ or Python for production usage if you intend to use the GNURadio framework for your own applications, GNURadio companion is a perfect tool for doing lab work and general signal hacking. GNURadio companion uses a graphical editor to layout GNURadio blocks and connect them together. GNURadio blocks GNURadio uses a concept of signal processing blocks. Those blocks can be written in a variety of languages, from Python to C++, with C++ implementations being usually faster than Python. There is documentation on the GNURadio wiki about writing modules, that might or might not be matching the current version of GNURadio, but will in any case provide a bit of help. ToDo: describe the blocks, what they do, etc. Other useful utilities Those are utilities I have found really useful in working with new signals: gqrx gqrx is an easy(ish) to use software defined radio receiver, that is a great tool for quickly visualizing a signal. ToDo: examples of signals and how to recognize them URH Universal Radio Hacker is a lower level tool that can be very powerful to understand digital modulations and quickly do demodulation work. It comes with excellent documentation for an Open Source project, which is a really refreshing change. ToDo: examples of demodulating a signal with URH MacOS notes Macports does not have a URH port, but you can install all of its dependencies from macports. Then you can run it, but be sure to export CFLAGS=\"-I /opt/local/include before either doing a pip install or running from the source tree. In order to compile SDR extensions on MacOS with Macports, use the fork at https://github.com/elafargue/urh which supports that distribution. ToDo: URH tutorial Inspectrum Inspectrum is similar to URH but written in C++. It is fairly simple to build and is a good addition to any signal processing toolbox. SDR setups rtl-sdr USRP osmocom / BladeRF Simple analog operations FM Demodulation FM demodulation is fairly simple: a FM-modulated signal is a carrier whose frequency varies proportionnal to the signal that we want to transmit. See wikipedia for the basics. From a Gnuradio companion perspective, it is very simple to represent in a flowgraph: Flowgraph file is here . This is a good first example, because it covers the very basics of what digital signal processing of radio signals is about. A great introduction to this, in case you do not yet understand the principle of working with in-phase and quadrature (aka IQ) signal components, is the introduction by dspguru . AM Demodulation AM demodulation is similar: an AM-modulated signal is also a carrier, but this time the amplitude of this carrier varies along with the signal we want to transmit. We can simply demodulate this signal by detecting the envelope of the received signal: The most basic GNURadio flowgraph for this would be as follows: Flowgraph file is here . note: this refers to the example data file available at the excellent course at: http://www.csun.edu/~skatz/katzpage/sdr_project/ . You should look up this site to learn more able AM and SSB in relation to digital radio. SSB Demodulation Single side band is an energy-efficient variant of amplitude modulation. Essentially, it is AM modulation with the carrier suppressed, and only one of the sidebands transmitted. It is not difficult to modulate, but demodulating it is slightly more complex. There are a couple of DSP algorithms out there for doing this, but Weaver is by far the most popular because it is very well suited to software defined radio. Reference links: Very good overview of SSB demodulation techniques Course on Weaver demodulation with clear explanation of the technique (todo: insert flowgraph of my own SSB receiver) Digital operations Nowadays, radio signals are often used to transmit bits rather than analog information. This section covers the most common techniques used for doing this. Basics of digital operations Digital signals are usually modulated using a combination of the amplitude, frequency and phase of a signal. To make demodulation easier, binary data is often encapsulated into frames that usually contain: A start sequence, used by the demodulator to synchronise itself to the incoming bitstream Some sort of header that contains the expected length of the frame Error correcting codes, either throughout or at the end of the frame. The digital to analogue conversion, besides modulating a bitstream using Amplitude/Frequency/Phase or a combination of all of these, also uses a notion of \"symbols\": instead of doing a one-to-one conversion of a \"0\" or \"1\" into two discrete analogue signal states, a lot of modulation schemes take longer bit sequences, such as \"00\" \"01\" \"10\" \"11\" and turn them into multiple discrete analogue signal states. Those sequences are called \"symbols\" and allow increasing the density of information that is sent inside of each modulation state. A demodulator therefore needs to do the following on an incoming analog signal: Demodulate the analog signal to turn it in to a \"clean\" analogue signal with clear discrete states for each symbol Turn that demodulated analogue signal into a symbols by knowing exactly when to sample the signal state to turn it into symbols. This is called \"clock recovery\" Remap the symbols to bit values Find start sequences in the bitstream to get in sync Recover packet length \"Deframe\" the packet and check its CRC GNURadio provides a lot of blocks to do almost all of these operations, but start sequence detection and deframing is usually quite specific to each modulation type, and there is only a limited number of off the shelf blocks that can be used for this. You will often need to get into python - or C - and write your own blocks for those. The next couple of sections provide more details on some of the aspects of demodulation using GNURadio. Recovering a bitstream As we saw just above, at a high level, the steps usually are: Analogue signal reception from SDR Low Pass / frequency translate to center the signal around zero hertz Analogue demodulate Clock Recovery Bitstream decoding (NRZ, Manchester, inversion, etc) Bitstream deframing A good example of this whole chain is the AX25 receiver that is included in this repository, that covers all these steps using standard GNURadio blocks. Note that this is a bit more complex than raw FSK signals, because AX25 is transmitted over narrow-band HAM radio, so the flowgraph first demodulates the FM signal into an audio signal, then it does the actual Audio FSK (aka AFSK) demodulation. Clock recovery Clock recovery is essentially a process that decides when the analogue signal should be sampled to determine the symbol state. When it works well, clock recovery will sample exactly once per transmitted symbol. GNURadio provides several good clock recovery blocks in the \"Synchronizers\" category. Some of the blocks that are easier to use are: Clock Recovery MM Polyphase Clock Sync With those blocks, you will need to know the symbol rate and bitrate in advance, so that they can make the right decision for sampling the symbols. The AFSK AX25 decoder flow graph below is a good example of using the Polyphase Clock Sync or the Clock Recovery MM blocks. Processing bitstreams OOK / ASK This is one of the simplest kinds of digital modulation: a carrier that is simply turned on/off to transmit information, hence the \"OOK\" (On-Off keying) or \"ASK\" (Amplitude Shift Keying) acronyms. Useful demodulators rtl_433 is a great general purpose demodulator and decoder for OOK signals, and is able to decode more than a hundred types of simple sensors, from wireless alarm sensors to a bunch of weather sensors. rtlamr An rtl-sdr receiver for Itron ERT compatible smart meters operating in the 900MHz ISM band. Frequency shift keying Frequency Shift Keying, or \"FSK\", uses discrete frequency changes of a carrier signal for modulating a bitstream. The simplest FSk uses two frequencies, one for \"0\" and one for \"1\", but it is also possible to use a larger number of discrete frequencies to encode longer symbols - for example \"00\", \"01\", \"10\" and \"11\" can be transmitted using 4-FSK, i.e. four separate frequencies. FSK is usually demodulated using quadrature demodulation. Note that a FSK-modulated signal can be transmitted as a carrier changing over N frequencies (usually within a couple of hundred hertz of each other), or through discrete frequency changes of a signat that is FM or AM modulated. In the latter case, we usually talk about \"AFSK\", or \"Audio FSK\". Other kinds of FSK exist that were designed to improve specific aspects of this sort of modulation, such as power efficiciency. The wikipedia article on FSK is a nice introduction and easy to understand. Links https://github.com/handiko/gr-APRS A great tutorial: http://aaronscher.com/GNU_Radio_Companion_Collection/Audio_Modem_loop_back_test_FSK.html Another one: https://nccgroup.github.io/RFTM/fsk_receiver.html 2-AFSK The easiest way to demodulate a FSK transmission is to use a Quadrature demodulation block: the output of quadrature demodulation varies with the phase change that occurs at frequency transition between the FSK frequencies, so this is a good way to turn the signal into symbol states. Since 2-FSK uses only 2 frequencies, there is usually a direct mapping of the frequency to either a \"0\" or \"1\" value, though you have to keep in mind that the signal is often encoded for robustness and energy efficiency using differential or Manchester encoding. The sample AX25 receiver included in this repository is a great example of 2-AFSK reception. You can use this flowgraph and adapt it to other types of modulation fairly easily: Adjust the FSK deviation of the signal Adjust the birate Adjust the bitstream decoding after the binary slicer Note: as you can see on the flowgraph below, we are doing two demodulations. You have to keep in mind that FM modulation of an analogue signal modulates the carrier signal by an amount that is proportional to the original analogue signal, but multiplied by a \"modulation index\". For this reason, it is not possible to simply convert a FM-modulated signal into a FSK bitstream, you first need to demodulate the FM signal into the deviation-correct FSK analogue modulation, then demodulate that signal into a bitstream. GRC Flowgraph code 2-FSK A good example of a 2-FSK signal is the old school \"RTTY\" modulation N-FSK Links http://qradiolink.org/4fsk-viterbi-soft-symbol-decoding.html Phase shift keying OFDM Real world examples Broadcast FM Mono Stereo Stereo with RDS HD Radio Narrow band FM (\u201cWalkie Talkies\u201d) FRS transceiver Texas Instruments C1111 https://github.com/funoverip/gr-cc1111 ADSB reception ToDo: explain ADSB demodulation on both gnuradio (if that exists at all), and on native utilities dump1090 The dump1090 is the best known utility to receive ADS-B frames from planes and helicopters. It was originally created as a quick hack and abandonned by its creator, then taken over by a couple of other people, before finding a home with Flight Aware who are maintaining the most up to date version these days (2019.04). dump1090 works great on a Raspberry Pi, and the best way to install it is to clone the github repository, and build the debian package from there. BladeRF Micro support: I have opened a pull request to add support for the BladeRF micro. Note that the BladeRF micro does not seem to work nearly as well as the bespoke rtl-sdr based orange dongle of Flight Aware, I might need to spend more time working at the gain settings for that device. In theory it should be able to work as well as RTL-SDR dongles, especially if used with a LNA. GPS/GNSS Receiving There are several packages available out there to do GNSS demodulation. The most advanced is the creatively-named 'gnss-sdr' package available at https://github.com/gnss-sdr/gnss-sdr MacOS support notes for gnss-sdr 2019.04: gnss-sdr is avaible on MacPort but on an outdated version that basically crashes with any current SDR (rtlsdr/osmocom). it is possible to build on MacOS though, using the current version of GNURadio installed through Macports. There are good build instructions available on the main github README.md page for gnss-sdr which you should follow. Don't forget to add \"cmake -DENABLE_OSMOSDR=ON ..\" if you want OsmoSDR support (BladeRF, RTL-SDR etc). CAREFUL: be sure you do not have a lingering version of gnss-sdr installed through a package manager when you are trying to build from source, since it will usually make compilation fail. In particular, volk will leave a \"volk_gnss\" include path on the package manager paths (/opt/local/include for macports) that will mess up compilation, you might have to delete by hand. Also, make sure that in case you have an old homebrew install on /usr/local, none of the libraries gnss-sdr relies on are found on that path (check out the output of the cmake step). Testing Once everything is installed (installing from a source compilation does to /usr/local by default), you can follow the tutorial on the gnss-sdr website and download the test file. It should decode without issues. Frontends The Configurations page on the gnss-sdr website does a good job explaining how to configure a couple of frontends. As the main site mentions, be sure you use an active antenna - with a bias Tee if necessary - since the GPS signal is usually below the sensitivity level of most SDRs. BladeRF Micro configuration It appears that the BladeRF micro as it stands today cannot really receive GPS without external help: https://www.nuand.com/forums/viewtopic.php?t=4984 RTLSDR configuration Sending Careful: do not blindly broadcast your own GPS signals, this is illegal, and will lead to very serious trouble if you get caught doing this. gps-sdr-sim Available on github , it seems to be the reference. The current version as of 2019 works very well, and will accept 10Hz NMEA input as well as a couple or other formats, and is easy to extend. It is also compatible with multiple frontends and I have tested it with success on URSP SDRs. A great way to test this is to feed the generated \".bin\" file to gnss-sdr. Bluetooth WiFi Investigating unknown signals Using URH Writing a bitstream processor","title":"Gnuradio, yet another guide"},{"location":"#gnuradio-yet-another-guide","text":"","title":"Gnuradio, yet another guide"},{"location":"#preamble","text":"GNURadio is an amazing framework for all things related radio digital signal processing, and it is as powerful as it is daunting: it is a fairly venerable project started in 2001, and has always been a real adventure to install on any computer. The main gnuradio documentation, maintained on wiki.gnuradio.org, will usually help, but it is all in all fairly sparse and often quite arcane. There is a lot of material out there about GNURadio, with varying degrees of relevance, accuracy, compatibility with the current versions of GNURadio. This guide is an attempt at covering most of the basics of building GNURadio flowgraphs to process most common radio modulations, along with examples of more advanced software, often based on GNURadio, designed to fully demodulate various categories of radio signals. A common challenge for many newcomers is that GNURadio is before anything else a digital signal processing framework: despite the 'Lego'-like approach of building flowgraphs on GNURadio Companion, you will always be very limited in what you can achieve without proper understanding of the fundamentals of digital signal processing. There are a lot of excellent resources on the web for learning this (see the links section below), as well as many university courses, and if you are seriously planning to use GNURadio for real projects, learning - or taking a refresher on - digital signal processing is really a must. This guide is an attempt at getting you up and running on GNURadio as of early 2019, and introduce you to the basic building blocks of the framework, so that you can in turn use GNURadio for your own projects. Last, this guide is heavily biased towards MacOS, and everything in here is working with GNURadio version 3.7.14. YMMV.","title":"Preamble"},{"location":"#links","text":"A lot of the material in the following links is useful for learning not only about GNURadio, but also about digital signal processing. Introduction to quadrature signals by dspguru . An excellent and approachable paper. balint256 YouTube channel . The GNURadio video tutorial there is outdated, but contains a lot of great fundamentals, definitely worth a watch. http://complextoreal.com/tutorials/","title":"Links"},{"location":"#variants-of-gnuradio-mainnextetc","text":"GNURadio uses a concept of \"gnuradio\" and \"gnuradio-next\" for its stable and development branches. The stable branch is usually the way to go.","title":"Variants of GNURadio - main/next/etc"},{"location":"#installing-gnuradio","text":"https://wiki.gnuradio.org/index.php/InstallingGR is the official documentation. Below are my own notes on how to actually get it to work","title":"Installing GNURadio"},{"location":"#linux","text":"Most distributions do have a gnuradio package. Be careful though, those versions are often out of date, especially the 'stable' versions. My advice is to first check out the version of GNURadio that is available on your package manager, then decide whether you want to go to the trouble of going a source code install, which is not a super trivial task. That said, GNURadio has improved that respect a lot over the years by using their own Python system they call \"PyBOMBS\". If you want to attempt a source install, follow the guide at: https://wiki.gnuradio.org/index.php/InstallingGRFromSource","title":"Linux"},{"location":"#running-in-a-linux-vm","text":"While running GNURadio inside a Linux VM works fine, you will probably encounter performance issues when using it with physical SDR radios over USB, so a native version is usually preferable.","title":"Running in a Linux VM"},{"location":"#macos","text":"MacOS does run GNURadio quite well, and has its own install page on the GNURadio wiki: https://wiki.gnuradio.org/index.php/MacInstall As with Linux, using a package manager is a good idea if the package is not too outdated. Macports is usually considered as the most stable and maintained port for GNURadio, but Homebrew has been making great progress lately, and will get you up and running quite well. As of 2019.04, my advice is to go the Macports way to install the stable version of GNURadio, it does work well and closely follows the GNURadio project releases.","title":"MacOS"},{"location":"#macos-quirks","text":"As usual with Open Source projects, there are a bunch of weird quirks for running various parts of GNURadio, in particular when using Gnuradio Companion with Qt blocks: the symptom is the UI flickering very fast. This can be easily solved though, by configuring the global settings at ~/.gnuradio/config.conf with: [qtgui] style = native If you installed GNURadio through MacPorts, you might have to explicitly tell cmake to point to /opt/local when compiling OOT (\"Out of tree\") modules: cmake -DCMAKE_INSTALL_PREFIX=/opt/local ..","title":"MacOS quirks"},{"location":"#using-pybombs","text":"Apparently, some say this is possible on MacOS X... I have not attempted this.","title":"Using PyBOMBS"},{"location":"#optimization-tricks","text":"ToDo: speak about hardware acceleration, expectations of performance, etc.","title":"Optimization tricks"},{"location":"#gnuradio-companion","text":"GNURadio companion is the graphical flow graph editor of GNURadio, and a great way to do rapid prototyping on this framework. While you will probably want to work in either C++ or Python for production usage if you intend to use the GNURadio framework for your own applications, GNURadio companion is a perfect tool for doing lab work and general signal hacking. GNURadio companion uses a graphical editor to layout GNURadio blocks and connect them together.","title":"GNURadio companion"},{"location":"#gnuradio-blocks","text":"GNURadio uses a concept of signal processing blocks. Those blocks can be written in a variety of languages, from Python to C++, with C++ implementations being usually faster than Python. There is documentation on the GNURadio wiki about writing modules, that might or might not be matching the current version of GNURadio, but will in any case provide a bit of help. ToDo: describe the blocks, what they do, etc.","title":"GNURadio blocks"},{"location":"#other-useful-utilities","text":"Those are utilities I have found really useful in working with new signals:","title":"Other useful utilities"},{"location":"#gqrx","text":"gqrx is an easy(ish) to use software defined radio receiver, that is a great tool for quickly visualizing a signal. ToDo: examples of signals and how to recognize them","title":"gqrx"},{"location":"#urh","text":"Universal Radio Hacker is a lower level tool that can be very powerful to understand digital modulations and quickly do demodulation work. It comes with excellent documentation for an Open Source project, which is a really refreshing change. ToDo: examples of demodulating a signal with URH","title":"URH"},{"location":"#macos-notes","text":"Macports does not have a URH port, but you can install all of its dependencies from macports. Then you can run it, but be sure to export CFLAGS=\"-I /opt/local/include before either doing a pip install or running from the source tree. In order to compile SDR extensions on MacOS with Macports, use the fork at https://github.com/elafargue/urh which supports that distribution. ToDo: URH tutorial","title":"MacOS notes"},{"location":"#inspectrum","text":"Inspectrum is similar to URH but written in C++. It is fairly simple to build and is a good addition to any signal processing toolbox.","title":"Inspectrum"},{"location":"#sdr-setups","text":"","title":"SDR setups"},{"location":"#rtl-sdr","text":"","title":"rtl-sdr"},{"location":"#usrp","text":"","title":"USRP"},{"location":"#osmocom-bladerf","text":"","title":"osmocom / BladeRF"},{"location":"#simple-analog-operations","text":"","title":"Simple analog operations"},{"location":"#fm-demodulation","text":"FM demodulation is fairly simple: a FM-modulated signal is a carrier whose frequency varies proportionnal to the signal that we want to transmit. See wikipedia for the basics. From a Gnuradio companion perspective, it is very simple to represent in a flowgraph: Flowgraph file is here . This is a good first example, because it covers the very basics of what digital signal processing of radio signals is about. A great introduction to this, in case you do not yet understand the principle of working with in-phase and quadrature (aka IQ) signal components, is the introduction by dspguru .","title":"FM Demodulation"},{"location":"#am-demodulation","text":"AM demodulation is similar: an AM-modulated signal is also a carrier, but this time the amplitude of this carrier varies along with the signal we want to transmit. We can simply demodulate this signal by detecting the envelope of the received signal: The most basic GNURadio flowgraph for this would be as follows: Flowgraph file is here . note: this refers to the example data file available at the excellent course at: http://www.csun.edu/~skatz/katzpage/sdr_project/ . You should look up this site to learn more able AM and SSB in relation to digital radio.","title":"AM Demodulation"},{"location":"#ssb-demodulation","text":"Single side band is an energy-efficient variant of amplitude modulation. Essentially, it is AM modulation with the carrier suppressed, and only one of the sidebands transmitted. It is not difficult to modulate, but demodulating it is slightly more complex. There are a couple of DSP algorithms out there for doing this, but Weaver is by far the most popular because it is very well suited to software defined radio. Reference links: Very good overview of SSB demodulation techniques Course on Weaver demodulation with clear explanation of the technique (todo: insert flowgraph of my own SSB receiver)","title":"SSB Demodulation"},{"location":"#digital-operations","text":"Nowadays, radio signals are often used to transmit bits rather than analog information. This section covers the most common techniques used for doing this.","title":"Digital operations"},{"location":"#basics-of-digital-operations","text":"Digital signals are usually modulated using a combination of the amplitude, frequency and phase of a signal. To make demodulation easier, binary data is often encapsulated into frames that usually contain: A start sequence, used by the demodulator to synchronise itself to the incoming bitstream Some sort of header that contains the expected length of the frame Error correcting codes, either throughout or at the end of the frame. The digital to analogue conversion, besides modulating a bitstream using Amplitude/Frequency/Phase or a combination of all of these, also uses a notion of \"symbols\": instead of doing a one-to-one conversion of a \"0\" or \"1\" into two discrete analogue signal states, a lot of modulation schemes take longer bit sequences, such as \"00\" \"01\" \"10\" \"11\" and turn them into multiple discrete analogue signal states. Those sequences are called \"symbols\" and allow increasing the density of information that is sent inside of each modulation state. A demodulator therefore needs to do the following on an incoming analog signal: Demodulate the analog signal to turn it in to a \"clean\" analogue signal with clear discrete states for each symbol Turn that demodulated analogue signal into a symbols by knowing exactly when to sample the signal state to turn it into symbols. This is called \"clock recovery\" Remap the symbols to bit values Find start sequences in the bitstream to get in sync Recover packet length \"Deframe\" the packet and check its CRC GNURadio provides a lot of blocks to do almost all of these operations, but start sequence detection and deframing is usually quite specific to each modulation type, and there is only a limited number of off the shelf blocks that can be used for this. You will often need to get into python - or C - and write your own blocks for those. The next couple of sections provide more details on some of the aspects of demodulation using GNURadio.","title":"Basics of digital operations"},{"location":"#recovering-a-bitstream","text":"As we saw just above, at a high level, the steps usually are: Analogue signal reception from SDR Low Pass / frequency translate to center the signal around zero hertz Analogue demodulate Clock Recovery Bitstream decoding (NRZ, Manchester, inversion, etc) Bitstream deframing A good example of this whole chain is the AX25 receiver that is included in this repository, that covers all these steps using standard GNURadio blocks. Note that this is a bit more complex than raw FSK signals, because AX25 is transmitted over narrow-band HAM radio, so the flowgraph first demodulates the FM signal into an audio signal, then it does the actual Audio FSK (aka AFSK) demodulation.","title":"Recovering a bitstream"},{"location":"#clock-recovery","text":"Clock recovery is essentially a process that decides when the analogue signal should be sampled to determine the symbol state. When it works well, clock recovery will sample exactly once per transmitted symbol. GNURadio provides several good clock recovery blocks in the \"Synchronizers\" category. Some of the blocks that are easier to use are: Clock Recovery MM Polyphase Clock Sync With those blocks, you will need to know the symbol rate and bitrate in advance, so that they can make the right decision for sampling the symbols. The AFSK AX25 decoder flow graph below is a good example of using the Polyphase Clock Sync or the Clock Recovery MM blocks.","title":"Clock recovery"},{"location":"#processing-bitstreams","text":"","title":"Processing bitstreams"},{"location":"#ook-ask","text":"This is one of the simplest kinds of digital modulation: a carrier that is simply turned on/off to transmit information, hence the \"OOK\" (On-Off keying) or \"ASK\" (Amplitude Shift Keying) acronyms.","title":"OOK / ASK"},{"location":"#useful-demodulators","text":"rtl_433 is a great general purpose demodulator and decoder for OOK signals, and is able to decode more than a hundred types of simple sensors, from wireless alarm sensors to a bunch of weather sensors. rtlamr An rtl-sdr receiver for Itron ERT compatible smart meters operating in the 900MHz ISM band.","title":"Useful demodulators"},{"location":"#frequency-shift-keying","text":"Frequency Shift Keying, or \"FSK\", uses discrete frequency changes of a carrier signal for modulating a bitstream. The simplest FSk uses two frequencies, one for \"0\" and one for \"1\", but it is also possible to use a larger number of discrete frequencies to encode longer symbols - for example \"00\", \"01\", \"10\" and \"11\" can be transmitted using 4-FSK, i.e. four separate frequencies. FSK is usually demodulated using quadrature demodulation. Note that a FSK-modulated signal can be transmitted as a carrier changing over N frequencies (usually within a couple of hundred hertz of each other), or through discrete frequency changes of a signat that is FM or AM modulated. In the latter case, we usually talk about \"AFSK\", or \"Audio FSK\". Other kinds of FSK exist that were designed to improve specific aspects of this sort of modulation, such as power efficiciency. The wikipedia article on FSK is a nice introduction and easy to understand.","title":"Frequency shift keying"},{"location":"#links_1","text":"https://github.com/handiko/gr-APRS A great tutorial: http://aaronscher.com/GNU_Radio_Companion_Collection/Audio_Modem_loop_back_test_FSK.html Another one: https://nccgroup.github.io/RFTM/fsk_receiver.html","title":"Links"},{"location":"#2-afsk","text":"The easiest way to demodulate a FSK transmission is to use a Quadrature demodulation block: the output of quadrature demodulation varies with the phase change that occurs at frequency transition between the FSK frequencies, so this is a good way to turn the signal into symbol states. Since 2-FSK uses only 2 frequencies, there is usually a direct mapping of the frequency to either a \"0\" or \"1\" value, though you have to keep in mind that the signal is often encoded for robustness and energy efficiency using differential or Manchester encoding. The sample AX25 receiver included in this repository is a great example of 2-AFSK reception. You can use this flowgraph and adapt it to other types of modulation fairly easily: Adjust the FSK deviation of the signal Adjust the birate Adjust the bitstream decoding after the binary slicer Note: as you can see on the flowgraph below, we are doing two demodulations. You have to keep in mind that FM modulation of an analogue signal modulates the carrier signal by an amount that is proportional to the original analogue signal, but multiplied by a \"modulation index\". For this reason, it is not possible to simply convert a FM-modulated signal into a FSK bitstream, you first need to demodulate the FM signal into the deviation-correct FSK analogue modulation, then demodulate that signal into a bitstream. GRC Flowgraph code","title":"2-AFSK"},{"location":"#2-fsk","text":"A good example of a 2-FSK signal is the old school \"RTTY\" modulation","title":"2-FSK"},{"location":"#n-fsk","text":"","title":"N-FSK"},{"location":"#links_2","text":"http://qradiolink.org/4fsk-viterbi-soft-symbol-decoding.html","title":"Links"},{"location":"#phase-shift-keying","text":"","title":"Phase shift keying"},{"location":"#ofdm","text":"","title":"OFDM"},{"location":"#real-world-examples","text":"","title":"Real world examples"},{"location":"#broadcast-fm","text":"","title":"Broadcast FM"},{"location":"#mono","text":"","title":"Mono"},{"location":"#stereo","text":"","title":"Stereo"},{"location":"#stereo-with-rds","text":"","title":"Stereo with RDS"},{"location":"#hd-radio","text":"","title":"HD Radio"},{"location":"#narrow-band-fm-walkie-talkies","text":"","title":"Narrow band FM (\u201cWalkie Talkies\u201d)"},{"location":"#frs-transceiver","text":"","title":"FRS transceiver"},{"location":"#texas-instruments-c1111","text":"https://github.com/funoverip/gr-cc1111","title":"Texas Instruments C1111"},{"location":"#adsb-reception","text":"ToDo: explain ADSB demodulation on both gnuradio (if that exists at all), and on native utilities","title":"ADSB reception"},{"location":"#dump1090","text":"The dump1090 is the best known utility to receive ADS-B frames from planes and helicopters. It was originally created as a quick hack and abandonned by its creator, then taken over by a couple of other people, before finding a home with Flight Aware who are maintaining the most up to date version these days (2019.04). dump1090 works great on a Raspberry Pi, and the best way to install it is to clone the github repository, and build the debian package from there. BladeRF Micro support: I have opened a pull request to add support for the BladeRF micro. Note that the BladeRF micro does not seem to work nearly as well as the bespoke rtl-sdr based orange dongle of Flight Aware, I might need to spend more time working at the gain settings for that device. In theory it should be able to work as well as RTL-SDR dongles, especially if used with a LNA.","title":"dump1090"},{"location":"#gpsgnss","text":"","title":"GPS/GNSS"},{"location":"#receiving","text":"There are several packages available out there to do GNSS demodulation. The most advanced is the creatively-named 'gnss-sdr' package available at https://github.com/gnss-sdr/gnss-sdr","title":"Receiving"},{"location":"#macos-support-notes-for-gnss-sdr","text":"2019.04: gnss-sdr is avaible on MacPort but on an outdated version that basically crashes with any current SDR (rtlsdr/osmocom). it is possible to build on MacOS though, using the current version of GNURadio installed through Macports. There are good build instructions available on the main github README.md page for gnss-sdr which you should follow. Don't forget to add \"cmake -DENABLE_OSMOSDR=ON ..\" if you want OsmoSDR support (BladeRF, RTL-SDR etc). CAREFUL: be sure you do not have a lingering version of gnss-sdr installed through a package manager when you are trying to build from source, since it will usually make compilation fail. In particular, volk will leave a \"volk_gnss\" include path on the package manager paths (/opt/local/include for macports) that will mess up compilation, you might have to delete by hand. Also, make sure that in case you have an old homebrew install on /usr/local, none of the libraries gnss-sdr relies on are found on that path (check out the output of the cmake step).","title":"MacOS support notes for gnss-sdr"},{"location":"#testing","text":"Once everything is installed (installing from a source compilation does to /usr/local by default), you can follow the tutorial on the gnss-sdr website and download the test file. It should decode without issues.","title":"Testing"},{"location":"#frontends","text":"The Configurations page on the gnss-sdr website does a good job explaining how to configure a couple of frontends. As the main site mentions, be sure you use an active antenna - with a bias Tee if necessary - since the GPS signal is usually below the sensitivity level of most SDRs.","title":"Frontends"},{"location":"#bladerf-micro-configuration","text":"It appears that the BladeRF micro as it stands today cannot really receive GPS without external help: https://www.nuand.com/forums/viewtopic.php?t=4984","title":"BladeRF Micro configuration"},{"location":"#rtlsdr-configuration","text":"","title":"RTLSDR configuration"},{"location":"#sending","text":"Careful: do not blindly broadcast your own GPS signals, this is illegal, and will lead to very serious trouble if you get caught doing this.","title":"Sending"},{"location":"#gps-sdr-sim","text":"Available on github , it seems to be the reference. The current version as of 2019 works very well, and will accept 10Hz NMEA input as well as a couple or other formats, and is easy to extend. It is also compatible with multiple frontends and I have tested it with success on URSP SDRs. A great way to test this is to feed the generated \".bin\" file to gnss-sdr.","title":"gps-sdr-sim"},{"location":"#bluetooth","text":"","title":"Bluetooth"},{"location":"#wifi","text":"","title":"WiFi"},{"location":"#investigating-unknown-signals","text":"","title":"Investigating unknown signals"},{"location":"#using-urh","text":"","title":"Using URH"},{"location":"#writing-a-bitstream-processor","text":"","title":"Writing a bitstream processor"}]}